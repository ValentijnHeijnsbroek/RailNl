from railnl import RailNL
import random
import math  # Import the math module for exp function
from station import Station
import copy
from help_funtions import *
from greedy import greedy_algorithm

max_aantal_trajecten = 20
max_aantal_minuten = 180

def simulated_annealing(temperature, cooling_rate, iterations):
    rail_at_max_score = initialize_rail()
    current_rail = initialize_rail()
    best_score = 0

    for iteration in range(iterations):
        current_temperature = temperature * math.exp(-cooling_rate * iteration)

        # Generate a new solution
        new_rail = generate_new_solution(current_rail)

        # Calculate scores
        current_score = current_rail.get_score()
        new_score = new_rail.get_score()

        # Decide whether to accept the new solution
        if accept_solution(current_score, new_score, current_temperature):
            current_rail = copy.deepcopy(new_rail)

            # Update the best solution if needed
            if new_score > best_score:
                best_score = new_score
                rail_at_max_score.trajecten = copy.deepcopy(current_rail.trajecten)

    return rail_at_max_score

def generate_new_solution(current_rail):
    if len(current_rail.trajecten) <= 1:
        new_rail = greedy_algorithm(100)
    else:
        new_rail = copy.deepcopy(current_rail)

    # Randomly select a traject to modify
    if len(new_rail.trajecten) == 1:
        traject_index = 1
    elif len(new_rail.trajecten) == 0:
        new_rail.create_traject(1)
        traject_index = 1
    elif len(new_rail.trajecten) > 1:
        traject_index = random.randint(1, len(new_rail.trajecten))


   # Delete the last two stations if the traject is longer than 3 stations
    traject = new_rail.trajecten[traject_index]
    if len(traject.traject_stations) > 3:
        # print(f"Deleting: {traject.traject_stations[-1].name}")
        traject.delete_latest_station()
        # print(f"Deleting: {traject.traject_stations[-1].name}")
        traject.delete_latest_station()
        greedy_station = greedy_decision(new_rail, traject_index)
        if greedy_station:
            traject.add_station_to_traject(greedy_station)
        greedy_station_2 = greedy_decision(new_rail, traject_index)
        if greedy_station_2:
            traject.add_station_to_traject(greedy_station_2)

    elif len(traject.traject_stations) >= 2:
        traject.delete_latest_station()
        random_station = traject.random_connected_station()
        traject.add_station_to_traject(random_station)
        
    
    return new_rail

def accept_solution(current_score, new_score, temperature):
    if new_score > current_score:
        return True
    else:
        probability = math.exp((new_score - current_score) / temperature)
        return random.uniform(0, 1) < probability

# Set parameters for simulated annealing
initial_temperature = 1000
cooling_rate = 0.005
iterations = 1000

rail_at_max_score = simulated_annealing(initial_temperature, cooling_rate, iterations)
rail_at_max_score.print_output()
rail_at_max_score.upload_output('output_simulated_annealing.csv')