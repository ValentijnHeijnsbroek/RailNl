from railnl import RailNL
import random
import math  # Import the math module for exp function
from station import Station
import copy
from help_funtions import *
from greedy import greedy_algorithm
import matplotlib.pyplot as plt
from IPython.display import clear_output
# highscore is 8651
max_aantal_trajecten = 20
max_aantal_minuten = 180
max_iterations_without_improvement = 80

def simulated_annealing(temperature, cooling_rate, iterations, greedy_iterations = 1000):
    rail_at_max_score = initialize_rail()
    current_rail = initialize_rail()
    best_score = 0
    best_iteration = 0
    best_iterations_list = []
    best_scores_list = []
    iterations_list = []
    scores_list = []
    iterations_without_improvement = 0

    for iteration in range(iterations):
        # Print progress of iterations
        if iteration/iterations * 100 % 10 == 0:
            print(f"{iteration/iterations * 100}%")
  
        current_temperature = temperature * math.exp(-cooling_rate * iteration)
        
        # Generate a new solution
        new_rail = generate_new_solution(current_rail, greedy_iterations)

        # Calculate scores
        current_score = current_rail.get_score()
        new_score = new_rail.get_score()

        iterations_list.append(iteration)
        scores_list.append(new_score)

        # Decide whether to accept the new solution
        if accept_solution(current_score, new_score, current_temperature):
            current_rail = copy.deepcopy(new_rail)

            # Update the best solution if needed
            if new_score > best_score:
                best_score = new_score
                best_iteration = iteration
                best_iterations_list = iterations_list
                best_scores_list = scores_list
                rail_at_max_score.trajecten = copy.deepcopy(current_rail.trajecten)
                iterations_without_improvement = 0
            else:
                iterations_without_improvement += 1 
        
        if iterations_without_improvement >= max_iterations_without_improvement and iteration > 600:
            print(f"Breaking out of the loop due to no improvement in {max_iterations_without_improvement} iterations.")
            break
    plt.plot(best_iterations_list, best_scores_list, label="Score")
    plt.axvline(x=best_iteration, color='r', linestyle='--', label=f'Highest Score: {best_score}')
    plt.xlabel("Iterations")
    plt.ylabel("Score")
    plt.title("Simulated Annealing Progress")
    plt.legend()
    plt.savefig('Simulated_Annealing_process.png')
    # plt.show()
    plt.close()

    return rail_at_max_score

def generate_new_solution(current_rail, greedy_iterations):
    if len(current_rail.trajecten) <= 1:
        new_rail = greedy_algorithm(greedy_iterations)
        # new_rail.print_output()
        print("Greedy succesfully loaded, greedy has a score of: ", new_rail.get_score())
    else:
        new_rail = copy.deepcopy(current_rail)

    operation = random.choice(['add_station', 'delete_station','substitute_stations'])

    traject_index = random.randint(1, len(new_rail.trajecten))

    #if selected traject is empty, add a random station
    if new_rail.trajecten[traject_index].traject_stations == []:
        begin_station = random.choice(new_rail.stations)
        new_rail.trajecten[traject_index].add_station_to_traject(begin_station)

    
    if operation == 'add_station':
        # Implement logic to add a station to an existing traject
  
        new_station = new_rail.trajecten[traject_index].random_connected_station()
        last_station = new_rail.trajecten[traject_index].last_station()
        # duration = last_station.get_duration(new_station)
        duration = last_station.get_duration(new_station)
        # Check if the new station can be added to the traject
        if new_station and new_rail.sum_time(traject_index) + duration <= max_aantal_minuten:
            new_rail.trajecten[traject_index].add_station_to_traject(new_station)
        else:
            operation = 'substitute_stations'

    elif operation == 'delete_station':
        # Implement logic to delete a station from an existing traject
        traject_index = random.randint(1, len(new_rail.trajecten))
        if new_rail.trajecten[traject_index].traject_stations:
            new_rail.trajecten[traject_index].delete_latest_station()
    
    elif operation == 'substitute_stations':
        # logic to substitute the latest two stations from a trajectory with a random station and then a greedy station
        traject_index = random.randint(1, len(new_rail.trajecten))
        traject = new_rail.trajecten[traject_index]
        if len(traject.traject_stations) >= 3:
            traject.delete_latest_station()
            traject.delete_latest_station()
            random_station = traject.random_connected_station()
            if random_station:
                traject.add_station_to_traject(random_station)
            greedy_station_2 = greedy_decision(new_rail, traject_index)
            if greedy_station_2:
                traject.add_station_to_traject(greedy_station_2)
        
    return new_rail

def accept_solution(current_score, new_score, temperature):
    if new_score > current_score:
        return True
    else:
        probability = math.exp((new_score - current_score) / temperature)
        return random.uniform(0, 1) < probability
    
def run_simulated_annealing(num_runs, temperature, cooling_rate, iterations, greedy_iterations = 1000):
    best_rail = None
    best_score = 0

    for run in range(1, num_runs + 1):
        print(f"Run {run}/{num_runs}")

        rail_at_max_score = simulated_annealing(temperature, cooling_rate, iterations, greedy_iterations)
        current_score = rail_at_max_score.get_score()

        print(f"Score for run {run}: {current_score}")
        if run/num_runs * 100 % 10 == 0:
            print(f"Best score at {run/num_runs * 100}% == {best_score}")

        if current_score > best_score:
            best_score = current_score
            best_rail = copy.deepcopy(rail_at_max_score)

    return best_rail


# Set parameters for the entire process
num_runs = 10
initial_temperature = 1000
cooling_rate = 0.005
iterations = 1500
greedy_iterations = 1000

# Run simulated annealing multiple times and get the best rail
best_rail = run_simulated_annealing(num_runs, initial_temperature, cooling_rate, iterations, greedy_iterations)

# Print and save the best rail
if best_rail is not None:
    print("Best Rail:")
    best_rail.print_output()
    best_rail.upload_output('output_simulated_annealing.csv')

# rail_at_max_score = simulated_annealing(initial_temperature, cooling_rate, iterations)
# rail_at_max_score.print_output()
# rail_at_max_score.upload_output('output_simulated_annealing.csv')

